## Introduction
> In this series of articles, I will share my experiences about microservices architectures with the 
community.

This article provides an introduction to microservices architecture. 

I will describe you all pieces of microservice architecture and how they fit together. Let's solve this puzzle together, piece by piece!

Components of Microservices architecture:

1. API gateway
2. Security
3. Service discovery
4. Client side load balancing
5. Circuit Breaker: Fault tolerance and resilience
6. Dynamic Configuration
7. Inter-process communication
8. Distributed tracing
9. Transactions
10. Agreggated logging
11. Centralized metrics & monitoring

`insert diagram`

## Api Gateway

API Gateway is an infrastructural pattern for interfacing external clients with the internal services. It represents a single point of entry into the application.


Responsibilities of the API Gateway component:

1. Rate limit / throttling
2. Security
2.1. SSL termination
2.2. Token translation
3. Logging
4. Caching
5. Load balancing
6. API monitoring and analytics

Open source API Gateway solutions / libraries:

1. Nginx
2. Zuul
3. Envoy

Enterprise users would want to look at API Management platforms which are offering additional functionality:

1. Apigee
2. WSO2
3. IBM API Connect
4. Amazon API Gateway

## Security

Simplified view of security model that can be used when designing secure microservices architecture:

Actors in the system:

1. Clients
1.1. Web application
1.2. Mobile application
2. API Gateway
3. Identity Provider / Authorization service
4. Resource services



Authenticating web and mobile clients is done by submitting user credentials. If user credentials are valid application will allow user to establish the authenticated session.

There are numerous approaches on how to establish and maintain user sessions. In this section let's focus on the simple solution that will satisfy the most of your needs.

Before going into the more details, here are some general recommendations:

1. Use token based authentication scheme.
2. Exchange username and password for an access token. Access token is used as an session identifier. 
3. Store access token in cookie or local storage. Access token should be opaque. In other words, opaque means that token is by-ref token (e.g. ```23e20f2f-93c7-41ec-b282-684b5ec34718```). 
4. Use API gateway as an translation layer. API gateway checks if access token is valid against the Identity Provider. 
4.1. If access token is valid, convert incoming by-ref token into the JWT and pass it down to the services. JWT contains authorization roles that will be used by services to perform authorization.
4.2. If access token is not valid, return authorization exception.

Now, let's move up to the higher level. You will need to chose how are going to store access token on the client side. In the table below you can se what are disadvantages of each approach:
<table>
<tr>
<td><strong>Cookie cons</strong></td>
<td><strong/>Local storage cons</strong></td>
</tr>
<tr>
<td>
1. Vulnerable to CSRF attacks<br/>
2. Not mobile friendly<br/>
3. Complicated cross-domain support
</td>
<td>
1. Vulnerable to XSS attacks<br/>
2. Separate mechanism for file security</td>
</tr>
</table>

Why haven't we used JWT instead of by-ref token to maintain session on the client side?

1. Preventing Token explosion. No need to send large payload on each request.

## Service discovery

Responsibilities of the Service discovery component:

1. 





## Client side load balancing

tbd

## Circuit Breaker: Fault tolerance and resilience

tbd


Microsevrice size It should be small. Two Pizza Team rule.

If you cannot feed the team building a microservice with two pizzas, your
microservice is too big.

Making services too granular, or requiring too many dependencies on
other microservices, can introduce latency.

There is a reason why we use the word monolith: It implies a
rock big enough that it can kill you if it falls on you. When you start, your application is more like a pebble. It takes a certain amount of time and effort by a growing number of
developers to even approach monolith and therefore microservice territory.

plan, develop, and deploy features of a system in the cloud without tight coordination


[1](https://medium.com/beyond-the-manifesto/using-api-gateways-and-jwts-for-identity-management-in-microservice-based-apis-9ba275864cef)













